<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lyon的博客</title>
  <icon>https://www.gravatar.com/avatar/6549a02b75f4b3821358f27a0a15242c</icon>
  <subtitle>极简主义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//litten.me/"/>
  <updated>2018-02-23T05:39:46.416Z</updated>
  <id>//litten.me/</id>
  
  <author>
    <name>Lyon</name>
    <email>lyon1999@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>情人节</title>
    <link href="//litten.me/2018/02/14/20180214ValentineDay/"/>
    <id>//litten.me/2018/02/14/20180214ValentineDay/</id>
    <published>2018-02-14T14:55:00.000Z</published>
    <updated>2018-02-23T05:39:46.416Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/dragon.jpg" alt="Picture by Matt Carlson"></p><p>女人，一种奇怪的生物，仿佛天生为购物而生，促进了经济，繁荣了市场</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/dragon.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;p&gt;女人，一种奇怪的生物，仿佛天生为购物而生，促进了经济，繁荣了市场&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="感悟" scheme="//litten.me/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>大话同步异步和阻塞非阻塞</title>
    <link href="//litten.me/2018/01/23/20180123concurrency1/"/>
    <id>//litten.me/2018/01/23/20180123concurrency1/</id>
    <published>2018-01-23T14:55:00.000Z</published>
    <updated>2018-02-23T04:55:41.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/aj.jpg" alt="Picture by Matt Carlson"></p><h3 id="“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。"><a href="#“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。" class="headerlink" title="“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。"></a>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。</h3><p>1.同步与异步<br>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由调用者主动等待这个调用的结果。<br>而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。<br>典型的异步编程模型比如Node.js<br>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。<br>2.阻塞与非阻塞<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>还是上面的例子，<br>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><h3 id="二、-老张爱喝茶，废话不说，煮开水。"><a href="#二、-老张爱喝茶，废话不说，煮开水。" class="headerlink" title="二、 老张爱喝茶，废话不说，煮开水。"></a>二、 老张爱喝茶，废话不说，煮开水。</h3><p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~的噪音。<br>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。<br>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。<br>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/aj.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。&quot;&gt;&lt;a href=&quot;#“
      
    
    </summary>
    
    
      <category term="技术" scheme="//litten.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017回顾</title>
    <link href="//litten.me/2017/12/31/20171231review/"/>
    <id>//litten.me/2017/12/31/20171231review/</id>
    <published>2017-12-31T14:55:00.000Z</published>
    <updated>2018-01-17T10:44:59.232Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/diary-29.jpg" alt="Picture by Matt Carlson"></p><h3 id="扬起帆"><a href="#扬起帆" class="headerlink" title="扬起帆"></a>扬起帆</h3><p>过去的一年，自己的大部分时间依然在路上，从北到南至西向东，走走停停断断续续，唯有书常伴。看到过去的事，常会让人觉知社会的确在发展。看到现在的事，又会令人知道社会还要再改进，对于个人何尝不是如此的。生活是欣欣向荣的，就算被一时所困，心中也要这样想，正如不管阴天还是晴朗，太阳都会照常升起。我们生活在一个相对安定的国度，远离混乱已经四十年，远离战争已经七十年。所以提醒自己常怀惕惕之心，不可因为愤懑而丧失了前进的动力。书要好好读，事要好好做。</p><p>近来冒出佛系青年一说，个人感觉他们人在彀中，又不甘此生如此，只好自称向佛，回避世事。他们想象自己遁入空门，便不会有什么烦恼，又不好真的出家，因此还是要火居的。就好比一个人想要隐居，却又要求住在别墅，不能断网，可以收发快递一样。青年想要抗争时代，最终依然会被卷入汹汹的浪涛之中，二十年前流行的词汇是弄潮儿，现在流行的词汇应该是潮弄儿，顺势而为才是大势所趋。<br>好了，废话连篇，不码字了，天亮了。</p><p>2018，请对我温柔点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/diary-29.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;扬起帆&quot;&gt;&lt;a href=&quot;#扬起帆&quot; class=&quot;headerlink&quot; title=&quot;扬起帆&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="生活" scheme="//litten.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>横向越权与纵向越权</title>
    <link href="//litten.me/2017/11/15/20171115unauthorized/"/>
    <id>//litten.me/2017/11/15/20171115unauthorized/</id>
    <published>2017-11-15T14:55:00.000Z</published>
    <updated>2018-02-23T05:06:46.563Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/mediator1.jpg" alt="Picture by Matt Carlson"></p><h3 id="横向越权"><a href="#横向越权" class="headerlink" title="横向越权"></a>横向越权</h3><p>横向越权指的是攻击者尝试访问与他拥有相同权限的用户的资源<br>如何防止横向越权漏洞：<br>1.可通过建立用户和可操作资源的绑定关系，用户对任何资源进行操作时，通过该绑定关系确保该资源是属于该用户所有的。<br>2.对请求中的关键参数进行间接映射，避免使用原始关键参数名，比如使用索引1代替id值123等<br>比如重置密码，要校验一下这个用户的旧密码,一定要指定是这个用户</p><h3 id="纵向越权"><a href="#纵向越权" class="headerlink" title="纵向越权"></a>纵向越权</h3><p>纵向越权指的是一个低级别攻击者尝试访问高级别用户的资源<br>如何防止纵向越权漏洞：<br>建议使用基于角色访问控制机制来防止纵向越权攻击，即预先定义不同的权限角色，为每个角色分配不同的权限，每个用户都属于特定的角色，即拥有固定的权限，当用户执行某个动作或产生某种行为时，通过用户所在的角色判定该动作或者行为是否允许。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/mediator1.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;横向越权&quot;&gt;&lt;a href=&quot;#横向越权&quot; class=&quot;headerlink&quot; title=&quot;横向越权&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="//litten.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>扒一扒Servlet源码</title>
    <link href="//litten.me/2017/10/01/20171001ServletSource/"/>
    <id>//litten.me/2017/10/01/20171001ServletSource/</id>
    <published>2017-10-01T14:55:00.000Z</published>
    <updated>2018-02-23T06:07:57.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet结构"><a href="#Servlet结构" class="headerlink" title="Servlet结构"></a>Servlet结构</h3><p><img src="/assets/blogImg/servlet1.jpg" alt="Picture by Matt Carlson"></p><h3 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1.Servlet"></a>1.Servlet</h3><p>Servlet 该接口定义了5个方法。</p><ul><li>init()，初始化 servlet 对象，完成一些初始化工作。它是由 servlet 容器控制的，该方法只能被调用一次</li><li>service()，接受客户端请求对象，执行业务操作，利用响应对象响应客户端请求。</li><li>destroy()，当容器监测到一个servlet从服务中被移除时，容器调用该方法，释放资源，该方法只能被调用一次。</li><li>getServletConfig()，ServletConfig 是容器向 servlet 传递参数的载体。</li><li>getServletInfo()，获取 servlet 相关信息。</li></ul><p>Servlet 的生命周期：<br>1，初始化阶段 调用 init() 方法<br>2，响应客户请求阶段　　调用 service() 方法<br>3，终止阶段　　调用 destroy() 方法<br>在 Servlet 接口中的五个方法中涉及的接口有三个：ServletConfig 、 ServletRequest、 ServletResponse<br>这里先讲讲 ServletRequest 和 ServletResponse。<br>1）ServletRequest 由 Servlet 容器来管理，当客户请求到来时，容器创建一个 ServletRequest 对象，封装请求数据，同时创建一个 ServletResponse 对象，封装响应数据。这两个对象将被容器作为 service（）方法的参数传递给 Servlet，Serlvet 利用 ServletRequest 对象获取客户端发来的请求数据，利用 ServletResponse 对象发送响应数据。<br>下面是 ServletRequest 中所有的方法，根据方法名大概就可以猜到这些方法到底是干啥用的。<br><img src="/assets/blogImg/servlet2.jpg" alt="Picture by Matt Carlson"><br>2）ServletResponse 发送响应数据<br><img src="/assets/blogImg/servlet3.jpg" alt="Picture by Matt Carlson"></p><h3 id="2-ServletConfig"><a href="#2-ServletConfig" class="headerlink" title="2.ServletConfig"></a>2.ServletConfig</h3><p>ServletConfig 是容器向 servlet 传递参数的载体。<br>ServletConfig的4个常用方法：<br>1）public String getInitParameter（String name）：返回指定名称的初始化参数值；<br>2）public Enumeration getInitParameterNames（）：返回一个包含所有初始化参数名的 Enumeration 对象；<br>3）public String getServletName()：返回在 DD 文件中<servlet-name>元素指定的 Servlet 名称；<br>4）public ServletContext getServletContext（）：返回该 Servlet 所在的上下文对象；<br>这里详细讲下 ServletContext ：<br><img src="/assets/blogImg/servlet4.jpg" alt="Picture by Matt Carlson"><br>Servlet上下文对象（ServletContext）：每个Web应用程序在被启动时都会创建一个唯一的上下文对象，Servlet 可通过其获得 Web 应用程序的初始化参数或 Servlet 容器的版本等信息，也可被 Servlet 用来与其他 Servlet 共享数据。<br>1、获得 ServletContext 应用：<br>（1）、直接调用 getServletContext（）方法<br>ServletContext context = getServletContext（）;<br>（2）、使用 ServletConfig 应用，再调用它的 getServletContext（）方法<br>ServletContext context = getServletConfig.getServletContext();<br>2、获得应用程序的初始化参数：<br>（1）、public String getInitParameter（String name）：返回指定参数名的字符串参数值，没有则返回 null；<br>（2）、public Enumeration getInitParameterNames()：返回一个包含多有初始化参数名的 Enumeration 对象；<br>3、通过 ServletContext 对象获得资源<br>（1）、public URl getResource（String path）:返回由给定路径的资源的 URL 对象，以 “/” 开头，为相对路径，相对于Web 应用程序的文档根目录；<br>（2）、public InputStream getResourceAsStream（String path）：从资源上获得一个 InputStream 对象，等价于getResource（path）.oprenStream();<br>（3）、public String getRealPath(String path)：返回给定的虚拟路径的真实路径；<br>4、登陆日志：使用 log（）方法可以将指定的消息写到服务器的日志文件中<br>（1）、public void log（String msg）：参数 msg 为写入日志文件消息<br>（2）、public void log（String msg，Throwable throwable）：将 msg 指定的消息和异常的栈跟踪信息写入日志文件<br>5、使用 RequestDispatcher 实现请求转发<br>（1）、RequestDispatcher getRequestDiapatcher(String path)：必须以 “/“ 开头相对于应用程序根目录，而ServletRequest 可以传递一个相对路径<br>（2）、RequestDipatcher getNamedDiapatcher（String name）：参数 name 为一个命名的 Servlet 对象<br>6、使用 ServletContext 对象存储数据<br>（1）、public void serAttribute（String name，Object object）：将给定名称的属性值对象绑定到上下文对象上；<br>（2）、public Object getAttribute（String name）：返回绑定到上下文对象的给定名称的属性值；<br>（3）、public Enumeration getAttributeNames()：返回绑定到上下文对象上的所有属性名的 Enumeration 对象；<br>（4）、public void removeAttribute（String name）：删除绑定到上下文对象指定名称的属性；<br>ServletRequest 共享的对象仅在请求的生存周期中可以被访问；<br>HttpSession 共享的对象仅在会话的生存周期中可以被访问；<br>ServletContext 共享的对象在整个 Web 应用程序启动的生存周期中可以被访问；<br>7、检索 Servlet 容器的信息<br>（1）、public String getServletInfo()：返回 Servlet 所运行容器的名称和版本；<br>（2）、public int getMajorVersion（）：返回容器所支持的 Servlet API 的主版本号；<br>（3）、public int getMinorVersion（）：返回容器所支持的 Servlet API 的次版本号；<br>（4）、public String getServletContext（）：返回 ServletContext 对应的 web 应用程序名称 <display-name>元素定义的名称；</display-name></servlet-name></p><h3 id="3-GenericServlet-抽象类"><a href="#3-GenericServlet-抽象类" class="headerlink" title="3.GenericServlet 抽象类"></a>3.GenericServlet 抽象类</h3><p>GenericServlet 定义了一个通用的，不依赖具体协议的 Servlet，它实现了 Servlet 接口和 ServletConfig 接口，它的方法在文章的第一张图就给出了。</p><h3 id="4-HttpServlet-抽象类"><a href="#4-HttpServlet-抽象类" class="headerlink" title="4.HttpServlet 抽象类"></a>4.HttpServlet 抽象类</h3><p>4.1、HTTP 请求方式<br><img src="/assets/blogImg/servlet5.jpg" alt="Picture by Matt Carlson"></p><pre><code>1. GET : 获取由请求 URL 标识的资源2. POST : 向 Web 服务器发送无限制长度的数据3. PUT : 存储一个资源到请求的 URL4. DELETE : 删除由 URL 标识的资源5. HEAD : 返回 URL 标识的头信息6. OPTIONS : 返回服务器支持的 HTTP 方法7. TRACE : 返回 TRACE 请求附带的头字段</code></pre><p>4.2、对应的服务方法：</p><pre><code>1. doGet() : 调用服务器的资源, 并将其作为响应返回给客户端. doGet() 调用在 URL 里显示正在传送给 Servlet 的数据,这在系统的安全方面可能带来一些问题, 比如说, 用户登录时, 表单里的用户名和密码需要发送到服务器端, doGet() 调用会在浏览器的 URL 里显示用户名和密码.2. doPost() : 它用于把客户端的数据传给服务端, 使用它可以以隐藏方式给服务器端发送数据. Post 适合发送大量数据.3. doPut() : 调用和 doPost() 相似, 并且它允许客户端把真正的文件存放在服务器上, 而不仅仅是传送数据.4. doDelete() : 它允许客户端删除服务器端的文件或者 Web 页面．它的使用非常少．5. doHead() : 它用于处理客户端的 Head 调用,并且返回一个 response. 当客户端只需要响应的 Header 时,它就发出一个Header 请求.这种情况下客户端往往关心响应的长度和响应的 MIME 类型.6. doOptions(): 它用于处理客户端的 Options 调用,通过这个调用, 客户端可以获得此 Servlet 支持的方法.如果 Servlet 覆盖了 doPost() 方法, 那么将返回: Allow: POST, TRACE, OPTIONS, HEAD7. doTrace：处理 TRACE 请求</code></pre><p>4.3、SERVLET SERVICE 方法详解<br><img src="/assets/blogImg/servlet6.jpg" alt="Picture by Matt Carlson"><br>4.4、HTTPSERVLET SERVICE 方法详解<br><img src="/assets/blogImg/servlet7.jpg" alt="Picture by Matt Carlson"><br><img src="/assets/blogImg/servlet8.jpg" alt="Picture by Matt Carlson"></p><h3 id="5-Servlet-的多线程问题"><a href="#5-Servlet-的多线程问题" class="headerlink" title="5.Servlet 的多线程问题"></a>5.Servlet 的多线程问题</h3><p>1、当涉及到 Servlet 需要共享资源是，需保证 Servlet 是线程安全的<br>2、注意事项：<br>（1）、用方法的局部变量保持请求中的专有数据；<br>（2）、只用 Servlet 的成员变量来存放那些不会改变的数据；<br>（3）、对可能被请求修改的成员变量同步（用 Synchronized 关键字修饰）；<br>（4）、如果 Servlet 访问外部资源，那么需要同步访问这些资源；<br>3、实现 SingleThreadModel 接口的 Servlet 在被多个客户请求时一个时刻只能有一个线程运行，不推荐使用。<br>4、如果必须在 servlet 使用同步代码，应尽量在最小的范围上（代码块）进行同步，同步代码越少，Servlet 执行才能越好，避免对 doGet() 或 doPost() 方法同步。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>全文首先通过一张 Servlet 中的核心 Servlet 类图关系，了解了几种 Servlet 之间的关系及其内部方法。然后在分别介绍这几种 Servlet，通过分析部分重要方法的源码来了解，还介绍了 Servlet 中多线程的问题的解决方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Servlet结构&quot;&gt;&lt;a href=&quot;#Servlet结构&quot; class=&quot;headerlink&quot; title=&quot;Servlet结构&quot;&gt;&lt;/a&gt;Servlet结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/servlet1.jpg&quot; al
      
    
    </summary>
    
    
      <category term="技术" scheme="//litten.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>九一八</title>
    <link href="//litten.me/2017/09/18/20170918/"/>
    <id>//litten.me/2017/09/18/20170918/</id>
    <published>2017-09-17T17:55:00.000Z</published>
    <updated>2018-02-23T05:34:28.385Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/diary-18.jpg" alt="Picture by Matt Carlson"></p><p>晚上打开电视机发现各个频道都在抗日，从什么东方主战场的纪录片到红色剧亮剑，再到戏曲沙家浜，无时无刻不在提醒人们不要忘记这场战争，但其实他的起点不是九一八，也不是七七，而是一百多年前甲午海上，吉野号击沉致远舰那一刻，他的范围也不仅波及中国，还包括暗杀闵妃侵占朝鲜半岛，日俄战争，入侵印度支那，，，辉煌时旭日旗飘遍大半个亚洲，黯淡时一个小男孩就让举国震荡，八月份吧，安倍在战后谈话中先向亚洲人民做了礼节性道歉，然后他说了，百年以前的世界，以西洋各国为中心，各国的殖民地在不断扩散，以压倒的技术优越性为背景，殖民地支配之波涌向了19世纪的亚洲。因之而产生的危机感，成为霓虹近代化的原动力，这是毫无疑问的。他还说了，经过席卷世界的第一次世界大战，霓虹民族自强的趋势在增强，给那时的殖民地化拉上了车闸。当初霓虹也加入了那场战争。但是由于发生了世界恐慌，欧美各国卷入了殖民地经济，并推进经济的分块化，这让霓虹经济遭受巨大打击。霓虹因此加深了孤立感，再加上外交和经济的停滞，让霓虹试图通过力量行使去寻找出路，，，感觉安倍的文采好鸡汤，其实一句话就可以总结他的意思，我们是一群追风筝的人，据说最冷漠的网络语言是呵呵，我想去对安倍说。聊聊过去也说说未来吧，毕竟神马都在延续，我看的抗日题材作品很少，两部吧，黑太阳731和冯导的紫日，日军细菌战人体实验，神风特攻队自杀式的武士道精神，还有一个人类的永恒话题，爱。如果要和霓虹谈爱，估计放到过去是要作死的节奏，现在也要被人骂，但我还是想试图去明确，铭记历史而不当作包袱，毕竟生活在继续，我们都头顶一个天，思考着现在或者未来，如何在东北亚和谐共生才是王道，追风筝的人里面描写了现在真实的阿富汗，战争，宗教，毒品，石刑，还有连小孩都不能幸免的性侵等等，这些东西离我们并不遥远，他们出现在一些人，一些国家，内心深出滋生出魔鬼的那一刻，百无聊赖，写写文字，纪念世界反法西斯战争胜利，对我自己而言，现在也慢慢变得试图讲述真相多于发表意见，因为真相常流失于涕泪交加中，启发每个人去独立思考…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/diary-18.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上打开电视机发现各个频道都在抗日，从什么东方主战场的纪录片到红色剧亮剑，再到戏曲沙家浜，无时无刻不在提醒人们不要忘记
      
    
    </summary>
    
    
      <category term="感悟" scheme="//litten.me/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>京城两日游</title>
    <link href="//litten.me/2017/05/14/20170514beijing/"/>
    <id>//litten.me/2017/05/14/20170514beijing/</id>
    <published>2017-05-14T14:55:00.000Z</published>
    <updated>2018-02-23T05:47:03.250Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/lijiang.jpg" alt="Picture by Matt Carlson"></p><h3 id="扬起帆"><a href="#扬起帆" class="headerlink" title="扬起帆"></a>扬起帆</h3><p>这两天京城小溜达哈，真像是刘姥姥进大观园，让俺这个历史爱好者和伪文青大饱眼福，跟演穿越剧似得一会古典一会现代，既感慨古人智慧，也惊叹现今创意，最后自惭形秽，自己的脑瓜子还是那么滴原生态，以前看历史书对乾隆自诩十全老人蛮不屑的，觉得言过其实，然而来了他住过的养性殿，看着那些很有个性，人情味的布局饰物，主人在墙上随性泼墨……觉的也是一枚可爱老头，也许只有体验，才会对别人多角度更乐观的对待。在798那会刚好碰到一场露天婚礼，毫无繁文缛节，一群年轻人就是在玩，简简单单，和传统的格格不入，但是这一切不变的可能就是变化自己吧，大知乎上看到一句话，人要掌握对抗时空扭曲的本领，忒不理解，现在觉得它说的是不是人随着生活稳定，每天固定的流水多了，待在舒适区里，感觉时间也过得快了，小时候什么都是新鲜的，这种感觉很少或不曾有，变化和活力会有关系吧，我也不知道……不码字了，有点瞌睡，谢谢这两天遇到的人和事</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/lijiang.jpg&quot; alt=&quot;Picture by Matt Carlson&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;扬起帆&quot;&gt;&lt;a href=&quot;#扬起帆&quot; class=&quot;headerlink&quot; title=&quot;扬起帆&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="游记" scheme="//litten.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
